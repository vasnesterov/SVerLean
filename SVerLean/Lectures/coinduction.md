## Коиндукция

В абстрактной форме пусть `U` - некоторое множество,
`F : 2^U → 2^U` - монотонная функция (т.е. если `A ⊆ B` то `F(A) ⊆ F(B)`)
Тогда теорема Кнастера-Тарского утверждает следующее:
у `F` есть наименьшая неподвижная точка `μF` и наибольшая неподвижная точка `νF`,
более того
`μF = ⋂ {X | F(X) ⊆ X}`
`νF = ⋃ {X | X ⊆ F(X)}`

Через наименьшую неподвижную точку определяются индуктивные типы: например
для `F(X) = {0} ∪ {x + 1 | x ∈ X}`, мы получим `μF = ℕ`. Это можно применять и
для типов вместо множеств: для `F(α) = Unit ⊕ (α × ℕ)` получим `μF ≃ List ℕ`.

Кроме того через теорему Кнастера-Тарского можно выразить и принцип индукции:
Если нужно доказать `∀ x ∈ ℕ, P x`, то есть `ℕ = μF ⊆ P`, достаточно показать
что `F(P) ⊆ P`, то есть буквально `0 ∈ P ∧ ∀ x ∈ P, x + 1 ∈ P`. Получается
стандартный принцип индукции. (Для типов вместо множеств это будет выглядеть
слегка иначе)

Что будет если мы рассмотрим не наименьшую неподвижную точку, а наибольшую?
Получатся т.н. коиндуктивные типы. Например если `F(α) = α × ℕ` то
`νF ≃ Stream ℕ` -- бесконечные последовательности натуральных чисел.
Если элементы индуктивных типов можно представлять как конечные термы из
конструкторов, то элементы коиндуктивных типов -- (возможно) бесконечные
термы, составленые из конструкторов, например
`0 :: 1 :: 2 :: ...` -- стрим из всех натуральных чисел.

Допустим у нас есть система переходов и мы хотим доказать что
`∀ t, s ⇒* t → P t`. На самом деле это коиндуктивный предикат `P* s`:

```
coinductive P* : State -> Prop
| step (h₁ : P s) (h₂ : ∀ t, s ⇒ t → P* t) : P* s
```
(P.S: в Lean коиндуктивных типов нет, так что это просто псевдокод)

Аналогично индуктивным предикатам, на коиндуктивные можно смотреть как
на такие, которые можно доказать (возможно бесконечным) термом-доказательством.

К примеру если в нашей системе есть два состояния `s₁` и `s₂`, которые переходят
друг в друга, и для которых верно `P` мы можем доказать `P* s₁` как-то так
(опуская детали)

```
example (h₁ : P s₁) (h₂ : P s₂) : P* s₁ :=
  step h₁ (step h₂ (step h₁ (...)))
```

Если бы мы заменили coinductive на inductive смысл бы поменялся и доказать
подобное мы не смогли бы.

Переведем это язык теории множеств. Вместо коиндуктивного типа возьмем
`F(X) = {s | s ∈ P ∧ ∀ t, s ⇒ t → t ∈ X}` (по сути переписали конструктор)
и объявим `P* := νF`. Нетрудно показать что `P* = {s | ∀ t, s ⇒* t → t ∈ P}`.
На всякий случай покажем:
1. `F(X)` это такие точки из `P` что из них за один шаг можно дойти только в `X`.
  `P*` это такие точки из которых за любое число шагов можно дойти только в `P`.
  Значит `F(P*)` это точки из `P` из которых за один шаг можно дойти только в `P*`.
  Значит из них за любое число шагов можно дойти только в `P`, т.е. `F(P*) ⊆ P*`.
  И обратно если за любое число шагов из `s` можно дойти только в `P`, то за один
  шаг можно попасть только в `P*`, то есть `P* ⊆ F(P*)`. (Формально здесь нужно
  рассуждать индукцией по пути). В общем, `P* = F(P*)`
2. Теперь покажем что `P*` максимальна. Пусть `A = F(A)`. То есть `A` - это
  подмножество `P` из которого за один шаг можно попасть только в `A`. Ну тогда
  за любое число шагов из любой точки `A` можно попасть только опять в `P` и тем
  самым `A ⊆ P*`.

Если мы хотим доказать что `∀ t, s₀ ⇒* t, P t`, то есть `s₀ ∈ P* = νF`, нам
достаточно найти такое `M` что
1. `s₀ ∈ M`
2. `M ⊆ F(M)`
  Чтобы было совсем похоже на то что было раньше можно расписать второе условие:
  `M ⊆ F(M) = P ∩ {s | ∀ t, s ⇒ t, t ∈ M}`, то есть на самом деле два условия:
    * `M ⊆ P`
    * `∀ s ∈ M, ∀ t, s ⇒ t, t ∈ M`

Из свойств 1 и 2 получим `s₀ ∈ M ⊆ νF`.
Получается полная аналогия с коиндукцией рассмотренной в `seminar_7.lean`.