/- ## Задача 1. Стандратные операции для арифметических выражений -/

/-- Тип для арифметических выражений. Любое выражение это -/
inductive ArithExpr : Type
/-- Либо число -/
| num : Int → ArithExpr
/-- Либо переменная -/
| var : String → ArithExpr
/-- Либо сумма двух выражений -/
| add : ArithExpr → ArithExpr → ArithExpr
/-- Либо произведение двух выражений -/
| mul : ArithExpr → ArithExpr → ArithExpr
/-- Либо выражение с противоположным знаком -/
| neg : ArithExpr → ArithExpr
deriving BEq

/- Напишите инстансы ниже: -/

instance : Add ArithExpr where
  add e₁ e₂ := sorry

instance : Sub ArithExpr where
  sub e₁ e₂ := sorry

instance : Mul ArithExpr :=
  sorry

instance : Neg ArithExpr :=
  sorry

def ArithExpr.toString (e : ArithExpr) : String :=
  sorry

instance : ToString ArithExpr :=
  sorry

instance (n : Nat) : OfNat ArithExpr n :=
  sorry

instance : Coe Int ArithExpr :=
  sorry

instance : Coe String ArithExpr :=
  sorry

#eval ("x" * (3 - 7 * "y") : ArithExpr)

/- ## Задача 2. Inhabited и неограниченные вычисления

В этой задаче мы смоделируем потенциально неограниченные вычисления
-/

/-- `Computation Q α` это тип для хранения состояния вычисления.
`Q` это произвольный тип состояний программы, `α` - тип возвращаемого значения

Вычисление может быть в одном из двух состояниях: -/
inductive Computation (Q : Type) (α : Type)
/-- В процессе, и находится в состоянии `q` -/
| inProgress (q : Q)
/-- Завершилось и вернуло результат `a` -/
| result (a : α)

structure Program (Q : Type) (α : Type) where
  /-- Начальное состояние -/
  initState : Q
  /-- Функция перехода -/
  nextState : Q → Computation Q α

/-- Напишите функцию для запуска программы. Если программа не завершилась через `maxSteps` шагов,
возвращается дефолтное значение, иначе - результат вычисления программы. -/
def Program.run {Q α : Type} [Inhabited α] (p : Program Q α) : α :=
  sorry

/-- Программа, складывающая первые `n` чисел. -/
def sumFirst : Program sorry Nat := sorry

/-- Программа, проверяющая что число простое. -/
def isPrime (n : Nat) : Program sorry Bool := sorry

/- Вообще в Lean есть возможность писать не совсем корректные рекурсивные функции, например: -/
def Nat.find (p : Nat → Bool) (n : Nat) : Nat :=
  if p n then
    n
  else
    find p (n + 1)
partial_fixpoint
/-
С вычислительной точки зрения эта функци работает ровно как написано.
С логической точки зрения функция, как она написана, некорректна, потому что
например `find (fun _ => false) 0` приводит к бесконечной рекурсии.
Ключевое слово `partial_fixpoint` модифицирует логическое определение следующим образом:
1. Lean доказывает что *существует* функция `find` удовлетворяющая этому определению
2. Использует аксиому выбора чтобы из доказательства существования получить функцию

К примеру, единственнное требование, накладываемое на значение `find (fun _ => false) 0` согласно
определению функции это требование ``find (fun _ => false) 0 = find (fun _ => false) 1`. Т.е. функция
`f (n : Nat) : Nat := default` подходит под рекурсивное определение `find`.
Чтобы `partial_fixpoint` сработало необходимо чтобы
1. Функция была записана в определенном виде - в виде так называемой хвостовой рекурсии
2. Возвращаемый тип был `Inhabited`
-/


/- ## Задача 3. Enumerable -/

/-- Класс для перечислимых типов: таких, элементы которых можно занумеровать.
Функция `num` по номеру выдает элемент. -/
class Enumerable (α : Type) where
  num : Nat → α

def num {α : Type} [inst : Enumerable α] (n : Nat) : α := inst.num n

/-- Натуральные числа занумеровать легко. -/
instance : Enumerable Nat where
  num n := n

/-- В принципе ничто не мешает нам так же занумеровать целые, хотя тогда нумерация не будет сюръективной.

Сюръективность нумерации можно потребовать, добавив
поле `num_surj: ∀ a : α, ∃ n : Nat, num n = a` в класс, и тогда инстанс ниже не пройдет.
Пока что с доказательствами мы не работаем, поэтому оставим как есть. Но в этой задаче требуется
сделать сюръективные нумерации.

Мы выставляем этому инстансу `priority := low` чтобы алгоритм вывода инстансов использовал его в
последнюю очередь при наличии альтернатив (например, другой нумерации целых чисел ниже). -/
instance (priority := low) : Enumerable Int where
  num n := Int.ofNat n

/-- Нумерация целых чисел в следующем порядке: `0, 1, -1, 2, -2, 3, -3, ...` -/
instance : Enumerable Int where
  num n :=
    match n with
    | 0 => 0
    | _ + 1 =>
      if n % 2 == 0 then
        -(n / 2 : Int)
      else
        (n + 1) / 2

#eval [(num 0 : Int), num 1, num 2, num 3, num 4, num 5]

/-- Напишите функцию которая ищет элемент перечислимого типа `α`, удовлетворяющий условию `p`. -/
def find {α : Type} [Enumerable α] (p : α → Bool) (maxSteps : Nat) : Option α :=
  sorry

/-- Если `α` перечислимый, то `Option α` тоже перечислимый. -/
instance (α : Type) [Enumerable α] : Enumerable (Option α) := sorry

/-- Если `α` и `β` перечислимые, то `α × β` перечислимый -/
instance (α β : Type) [Enumerable α] [Enumerable β] : Enumerable (α × β) := sorry

/-- Если тип перечислимый, на нем можно ввести порядок -/
instance (α : Type) [Enumerable α] : LT α := sorry

inductive BinTree
| leaf
| node (left : BinTree) (right : BinTree)

/-- Бонусный пункт на дом: занумеруйте бинарные деревья. -/
instance : Enumerable BinTree := sorry

/- ## Задача 4. Проверка на чётность -/

/-- Создадим класс `IsEven` без полей.

По хорошему у него должно быть поле `proof : n % 2 = 0`
содержаещее доказательство простоты. Но пока что с доказательствами мы не работаем.
-/
class IsEven (n : Nat)

/- Напишите инстансы для этого класса так чтобы `IsEven n` действительно выводилось
только для чётных `n`. Возможно понадобится вспомогательный класс.

P.S.: Это учебный пример, **в реальности так делать не следует**,
потому что это поручает алгоритму вывода инстансов работу, на которую он не заточен.
Подобный тайпкласс в реальности сделан по-другому, позже мы увидем как. -/

/- ## Задача 5*. Проверка на простоту -/

/- Сделайте то же что и в задаче выше, но для простых чисел. -/
class IsPrime (n : Nat)
