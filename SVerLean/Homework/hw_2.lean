import Std.Data.HashMap.Basic

/-
## Задача 1. NAND

Рассмотрим множество булевых формул составленных из переменных, констант `T` и `F`
и булевых связок `not`, `and`, `or`. Широко известно, что при помощи этих операций
можно выразить любую булеву функцию. Не так широко известно то, что любую булеву
функцию можно так же выразить через константы `T`, `F` и единственную операцию
`nand A B := not (A and B)`. В этой задаче требуется написать преобразование
формул одного вида в формулы другого.

По аналогии с семинарским `ArithExpr`:
1. Задайте тип `BooleanFormula` булевых формул через `inductive`
2. Напишите функцию `BooleanFormula.eval`, аналогичную `ArithExpr.eval` и
  принимающую `env : String → Bool`.
3. Задайте тип `NandFormula` для NAND-формул
4. Напишите функцию `NandFormula.eval`, аналогичную `BooleanFormula.eval`
5. Напишите функцию `BooleanFormula.toNandFormula` переводящую обычную булеву формулу
  в NAND-формулу
6. Протестируйте `BooleanFormula.toNandFormula` на паре-тройке формул. Тестировать можно так:
  для формулы `F : BooleanFormula` и `env : String → Bool` проверьте что
  `F.eval env = F.toNandFormula.eval env` при помощи команды `#guard`.
-/

/-
## Задача 2. Арифметические выражения + присвоение

На семинаре мы работали с арифметическими выражениями.

Сейчас мы рассмотрим простой "язык программирования" в котором можно только
вводить переменные и вычислять арифметические выражения. Например "программа"
```
  set x := 15
  set y := (x + 1) * (x + 3)
  set z := y * y - 3 * y + 3
```
вычисляет и сохраняет значения переменных {x ↦ 15, y ↦ 288, z ↦ 82083}

Задача: написать интерпретатор этого языка. Подробности ниже.
-/


namespace Arithmetic

/-- Тип арифметических выражений -/
inductive ArithExpr : Type
| num : Int → ArithExpr
| var : String → ArithExpr
| add : ArithExpr → ArithExpr → ArithExpr
| mul : ArithExpr → ArithExpr → ArithExpr
| neg : ArithExpr → ArithExpr

/-- Тип для инструкций "языка программирования". Пока что есть только один конструктор, то есть
только один тип инструкций. В дальнейшем можно, например, добавить оператор `if-then-else` или циклы. -/
inductive Instruction
| set (name : String) (expr : ArithExpr)

/-- Программа это просто список инструкций.  -/
abbrev Program : Type := List Instruction

/- Std.HashMap -/
#check Std.HashMap.emptyWithCapacity
#check Std.HashMap.insert
#check Std.HashMap.get!

/-- Состояние интерпретатора. В данном случае мы храним только `env` - хэш-мапу, в которой лежат
значения переменных. От нее вам хватит трёх функций выше.

P.S. Вообще, в VS Code можно набрать `#check Std.HashMap.` и поставить курсор за точку. Выпадет
список доступных функций с документацией. -/
structure State : Type where
  env : Std.HashMap String Int

/-- С семинара -/
def ArithExpr.eval (e : ArithExpr) (env : String → Int) : Int :=
  sorry

/-- Напишите функцию которая выполняет программу и возвращает стейт после исполнения программы.
Изначально стейт пустой. -/
def Program.run (program : Program) : State :=
  sorry

def testProgram : Program :=
  [.set "x" (.num 1), .set "y" (.num 2), .set "z" (.add (.var "x") (.var "y"))]

#guard testProgram.run.env.get! "z" == 3

end Arithmetic

/-
# Задача 3. Машина Минского

Машины Минского это очень простая вычислительная модель, которая, тем не менее,
Тьюринг-полна (то есть в теории может выполнить любое вычисление, на которое способен
компьютер).

В этой задаче нужно будет написать интерпретатор для таких машин и пару простых программ.
Подробности ниже.
-/
namespace MinskyMachine

/-- Состояние машины описывается тремя числовыми регистрами. -/
structure State : Type where
  registers : Vector Nat 3

/- В этой задаче используется тип `Fin`. `Fin n` это тип натуральных чисел от `0` до `n - 1`.

Значения `Fin 3` можно использовать как индексы в массиве типа `Vector α 3`, и при этом не нужно
доказывать корректность индекса (факт что `i : Fin 3` меньше `3` "вшит" в тип)

Элементы `Fin 3` можно задавать при помощи нумералов:
-/
def testIdx : Fin 3 := 2

/-- На этот раз у нас 3 типа инструкций. -/
inductive Instruction
/-- увеличить значение регистра `n` на единицу и перейти к следующей инструкции -/
| inc (n : Fin 3)
/-- перейти к инструкции номер `idx` -/
| goto (idx : Nat)
/-- Если `n`-ый регистр равен нулю, перейти к инструкции `gotoIdx`,
  иначе уменьшить `n`-ый регистр на единицу и перейти к следующей инструкции -/
| decGoto (n : Fin 3) (gotoIdx : Nat)

/-- Программа это просто массив инструкций -/
abbrev Program := Array Instruction

/-- Исполняет программу `program`. Изначальное состояние равно `state`.
Исполнение начинается с первой инструкции. Если при исполнении мы
вышли за пределы программы, вычисление останавливается.

Так как вычисление может быть бесконечным, мы запускаем программу максимум на `maxSteps`
шагов, после этого вычисление останавливается в любом случае. -/
def Program.run (program : Program) (state : State) (maxSteps : Nat) : State :=
  sorry

/-- Складывает первые два регистра во второй. Требование: если перед исполнением этой программы в первых
двух регистрах лежали числа `x` и `y`, то после исполнения во втором регистре должен быть `x + y`. -/
def sum : Program :=
  sorry

#guard (sum.run { registers := #v[33, 55, 42] } 10000).registers.toArray[1] == 88

/-- **БОНУС**

Меняет первые два регистра местами. Требование: если перед исполнением этой программы в первых
двух регистрах лежали числа `x` и `y`, то после исполнения в них должны лежать `y` и `x`. -/
def swap : Program :=
  sorry

#guard (swap.run { registers := #v[33, 55, 42] } 10000).registers.toArray[0:2].toArray == #[55, 33]

end MinskyMachine
